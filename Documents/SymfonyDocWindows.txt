############## INSTALLATION ET UTILISATION DE SYMFONY2 #####################

- Vérifiez si PHP est installé en console :  php -v

Variable d'environnement à MAJ si besoin  :  ex(C:\wamp\bin\php\php5.5.12;)

- Téléchargez symfony.phar dans le dossier : ex(C:\wamp\www)

Adresse suivante : http://symfony.com/installer

- Lancez l'installation CMD : php symfony.phar new Symfony

- Info utile si en mode DEV la mise en forme d'une page d'erreur est mauvaise

Dans le répertoire Symfony depuis le CMD : php bin/console assets:install

- Pour créer un Bundle dans le répertoire Symfony depuis le CMD : php bin/console generate:bundle

Bundle namespace: par convention => RACINE|Nomdubundle|Bundle(obligatoire)
Bundle name: par défaut
Target directory: par défaut
Configuration format: au choix (ex: yml)
structure: par défaut
Entrée x fois jusqu'à "generated code !"

- Nettoyage des éléments générés par Symfony2:

*Controller/DefautController.php
*Resources/views/Default
*La route "xxxx_xxxxx_homepage" dans Resources/config/routing.yml
*Le dossier AppBundle dans src/AppBundle
*La ligne 19 du fichier app/AppKernel.php, celle qui active le bundle: new AppBundle\AppBundle();
*Les lignes 5 à 7 du fichier app/config/routing.yml, celles qui importent le fichier de route 
du bundle AppBundle (app: resource: "@AppBundle/Controller/" type: annotation" ).

- Nettoyage du cache en mode DEV depuis le CMD: php bin/console cache:clear

- Installer Composer et Git

### COMPOSER ###

Téléchargement depuis le CMD à la racine de Symfony:

	php -r "eval('?>'.file_get_contents('http://getcomposer.org/installer'));"

Téléchargement depuis le navigateur:

	http://getcomposer.org/installer (fichier "installer" à mettre à la racine de symfony)

Vérifiez que tout est OK depuis le CMD: php composer.phar --version (Composer version xxxx)

Si besoin de le mettre à jour toujours depuis le CMD: php composer.phar self-update (Updating to version xxx.)

### GIT ###

Téléchargement ici : https://git-for-windows.github.io/

Installation suivant => suivant etc....

Variable d'environnement à MAJ: (ex: C:\Program Files\Git\bin;C:\Program Files\Git\mingw64\bin;)

### INSTALLER UN BUNDLE AVEC COMPOSER ###

Ouvrir le fichier "composer.json" situé à la racine de Symfony puis rajouter dans "require": {"twig/extensions": "~1.0"}

Ou au choix ici suivant vos besoins: https://packagist.org/packages/twig/extensions

! Attention à vérifier si votre version de PHP et de Symfony sont compatibles

Sauvegarder le fichier Json et dans le CMD saisissez la commande :   php composer.phar update

le contenu du dossier "Symfony/vendor" a été mis à jour !

### Générer une entité avec Doctrine ###

A l'aide du CMD dans le répertoire racine du projet :

	php bin/console generate:doctrine:entity

*Donnez lui un nom
*Choisissez le format par défault [annotation]
*Nom du premier champs
*Puis le type de champs
*Puis la longueur du champs
** Répétez l'opération autant de fois que vous avez de champs.
** Puis une fois terminé faites "Entrée" et choisissez "yes" pour générer pour créer un repository vide.

### Matérialiser les tables en Base de données ###

Avant tout vérifier le paramétrage dans : app/config/parameters.yml

Tout ce qui commence par "database_" c'est à dire host, name , user etc....

	Dans un premier temps il faut créer la Base de données à l'aide du CMD:

		php bin/console doctrine:database:create 

	Ensuite il faut générer la table:

		php bin/console doctrine:schema:update --dump-sql (cette commande affiche la ou les requêtes qu'elle s'apprête à exécuter suite à une coparaison faite entre la base de données et nos entités)

		php bin/console doctrine:schema:update --force (cette commande génère la ou les tables correspondantes à la requête précédente)

Voilà, si tout c'est bien passé votre Base de données à une ou plusieurs nouvelle(s) table(s).

### Créer les getter et les setter correspondant à un nouvel attribut de son entité ###

*Ecrire son attribut à la main dans le fichier de l'entité correspondant

exemple dans le fichier "C:\wamp\www\Symfony\src\FC\PlatformBundle\Entity\Advert"

Placez y l'attribut suivant : 

/**
  *
  * @ORM\Column(name="published", type="boolean")
  */
private $published = true;


*Ensuite afin de générer automatiquement les setters et les getters dans le CMD :

php bin/console doctrine:generate:entities FCPlatformBundle:Advert

Explication:"php bin/console doctrine:generate:entities [nomdubundle]:[nomdel'entité]

Et voilà vos setters et vos getters sont mis à jour.

Conclusion: La commande entity génère une entité entière alors que entities génère en fonction du mapping existant.

### Enregistrer ce nouveau schéma en Base de données ###

Depuis le CMD :

php bin/console doctrine:schema:update --dump-sql (Créer la requête)

Puis:

php bin/console doctrine:schema:update --force (Pour exécuter la requête)


### Enregistrer ses entités avec l'EntityManager ###

Le service doctrine est celui qui va nous permettre de gérer la persistance de nos objets depuis le contrôleur.

	$doctrine = $this->get('doctrine');

ou bien

	$doctrine = $this->getDoctrine();


Le service EntityManager de doctrine permet d'exécuter les requêtes SQL dans la Base de données.

	$em = $this->getDoctrine()->getManager();

ou bien

	$em = $this->get('doctrine.orm.entity_manager');

Les repositories sont des objets qui utilisent un EntityManager et qui est bien plus facile à utiliser. Il en existe un par entité, il faut donc toujours préciser l'entité concernée.

	$em = $this->getDoctrine()->getManager();
	$advertRepository = $em->getRepository('FCPlatformBundle:Advert');

Précision: Il y a deux façons de spécifier l'entité voulue dans getRepository:

	$em->getRepository('[chemincompletdel'entité]') ex: '[FC\PlatformBundle\Entity\Advert]'

ou alors

	$em->getRepository('[nomdubundle]:[nomdel'entité]') ex: '[FCPlatformBundle:Advert]'

! Attention ce raccourci ne fonctionne que si vous avez mis vos entités dans le namespace:

	ex: use FC\PlatformBundle\Entity\Advert;

### Procédure d'enregistrement d'un objet en Base de données ###

1) On créé l'entité objet

	$entity = new Advert();

2) On renseigne ses attributs

	$entity->setTitle('-----');
	$entity->setAuthor('--------');
	etc......

3) On récupère l'EntityManager

	$entityManager = $this->getDoctrine()->getManager();

4) On dit à Doctrine de persister l'entité

	$entityManager->persist($entity);

5) On dit à Doctrine d'exécuter les requêtes pour sauvegarder les entités précédemment persistées

	$entityManager->flush();

Et voilà le tour est joué, on peut maintenant récupérer l'id créé par exemple à l'aide de :

	$entity->getId();

### Effectuer une mise à jour d'un objet en Base de données ###

$entityManager = $this->getDoctrine()->getManager();

$entity = $entityManager->getRepository('FCPlatformBundle:Advert')->find(5);

$entity->setDate(new \Datetime());

$entity->flush();

### Autres méthodes utiles de l'EntityManager ###

clear() Annule tous les persist effectués

ex: $entityManager->persist($advert);
    $entityManager->persist($comment);
    $entityManager->clear();
    $entityManager->flush(); // N'exécutera rien car les deux persists sont annulés par le clear

detach() Annule le persist effectué sur l'entité en argument

ex: $entityManager->persist($advert);
    $entityManager->persist($comment);
    $entityManager->detach($advert);
    $entityManager->flush(); // Enregistre $comment mais pas $advert

contains() Retourne  true si l'entité donnée en argument a été persist

ex: $entityManager->persist($avert);
    var_dump($entityManager->contains($advert)); // Affiche true
    var_dump($entityManager->contains($comment)); // Affiche false

refresh() Met à jour l'entité donnée en argument dans l'état où elle est en Base de données

ex: $advert->setTitle('Un nouveau titre');
    $entityManager->refresh($advert);
    var_dump($advert->getTitle()); // " Affiche un ancien titre "

remove() Supprime l'entité donnée en argument de la base de données au prochain flush

ex: $entityManager->remove($advert);
    $entityManager->flush(); // Exécute un DELETE sur $advert

### Procédure de sélection en Base de données ###

1) On récupère le repository

$repository = $this->getDoctrine()->getManager()->getRepository('FCPlatformBundle:Advert');

2) On récupère l'entité correspondante à l'id $id

$advert = $repository->find($id);

Autre façon plus courte

	$advert = $this->getDoctrine()->getManager()->find('FCPlatformBundle:Advert', $id);

### Relation entre entités ###


	## Relation OneToOne ##

Créer une nouvelle entité 

	php bin/console generate:doctrine:entity

	*Donnez lui un nom
	*Choisissez le format par défault [annotation]
	*Nom du premier champs
	*Puis le type de champs
	*Puis la longueur du champs
	** Répétez l'opération autant de fois que vous avez de champs.
	** Puis une fois terminé faites "Entrée" et choisissez "yes" pour générer pour créer un repository vide.

Puis mettez à jour la Base de données

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

	Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

Ensuite pour une entité advert en propriétaire et image en inverse par exemple

Rajouter dans l'entité propriétaire Advert la liaison sous cette forme:

/**
  * @ORM\OneToOne(targetEntity="FC\PlatformBundle\Entity\Image", cascade={"persist"})
  */
private $image;


Ensuite mettez à jour la Base de données: 

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

	Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

Vous pouvez voir dans la table Advert la clé étrangère image_id a été rajoutée !

! Important  Par défaut une relation est facultative si vous voulez forcer la relation il faut ajouter dans Advert " @ORM\JoinColumn(nullable=false) " comme ceci:

/**
  * @ORM\OneToOne(targetEntity="FC\PlatformBundle\Entity\Image", cascade={"persist"})
  * @ORM\JoinColumn(nullable=false)
  */
private $image;

Ajoutez ensuite les getters et les setters à l'aide de la commande:

php bin/console doctrine:generate:entities FCPlatformBundle:Image


	## Relation ManyToOne ##

Créer une nouvelle entité 

	php bin/console generate:doctrine:entity

	*Donnez lui un nom
	*Choisissez le format par défault [annotation]
	*Nom du premier champs
	*Puis le type de champs
	*Puis la longueur du champs
	** Répétez l'opération autant de fois que vous avez de champs.
	** Puis une fois terminé faites "Entrée" et choisissez "yes" pour générer pour créer un repository vide.

Puis mettez à jour la Base de données

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

	Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

Ensuite pour une entité Application en propriétaire et une entité Advert en inverse par exemple

Rajoutez dans l'entité propriétaire Application:

/**
 * @ORM\ManyToOne(targetEntity="FC\PlatformBundle\Entity\Advert")
 * @ORM\JoinColumn(nullable=false)
 */
private $advert;

 Ensuite mettez à jour la Base de données: 

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

	Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

Vous pouvez voir dans la table Application la clé étrangère advert_id a été rajoutée !	

Ajoutez ensuite les getters et les setters à l'aide de la commande:

php bin/console doctrine:generate:entities FCPlatformBundle:Application

	## Relation ManyToMany ##

Advert One-To-Many AdvertCategory One-To-Many Category

Pour cette relation particulière Doctrine va devoir créer une table intermédiaire.

ex: Vous avez une table advert
	      une table category

Pour une relation ManyToMany il faut créer une table advert_category avec deux colonnes advert_id et category_id.

Créer une nouvelle entité category avec name 

	php bin/console generate:doctrine:entity

	*Donnez lui un nom
	*Choisissez le format par défault [annotation]
	*Nom du premier champs
	*Puis le type de champs
	*Puis la longueur du champs
	** Répétez l'opération autant de fois que vous avez de champs.
	** Puis une fois terminé faites "Entrée" et choisissez "yes" pour générer pour créer un repository vide.

Puis mettez à jour la Base de données

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

	Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)	 
Afin d'établir cette relation dans vos entités, la syntaxe est la suivante:

Entité propriétaire, Advert:

/**
      * @ORM\ManyToMany(targetEntity="FC\PlatformBundle\Entity\Category", cascade={"persist"})
      */
    private $categories;

Entité inverse, Category:

// Nul besoin d'ajouter une propriété

 Afin de générer les getters et les setters dans le CMD:

php bin/console doctrine:generate:entities FCPlatformBundle:Advert

ensuite mettre à jour la base de données :

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

		## Créer un fixture pour l'entité category ##

// src/FC/PlatformBundle/DataFixtures/ORM/LoadCategory.php

namespace FC\PlatformBundle\DataFixtures\ORM;

use Doctrine\Common\DataFixtures\FixtureInterface;
use Doctrine\Common\Persistence\ObjectManager;
use FC\PlatformBundle\Entity\Category;

class LoadCategory implements FixtureInterface
{
  // Dans l'argument de la méthode load, l'objet $manager est l'EntityManager
  public function load(ObjectManager $manager)
  {
    // Liste des noms de catégorie à ajouter
    $names = array(
      'Développement web',
      'Développement mobile',
      'Graphisme',
      'Intégration',
      'Réseau'
    );

    foreach ($names as $name) {
      // On crée la catégorie
      $category = new Category();
      $category->setName($name);

      // On la persiste
      $manager->persist($category);
    }

    // On déclenche l'enregistrement de toutes les catégories
    $manager->flush();
  }
}

Pour insérer ses données dans la base de données:

depuis le CMD:

php bin/console doctrine:fixtures:load

répondez 'y'

Et voilà les catégories sont créées !

	## Relation ManyToMany avec attributs ##

Advert One-To-Many AdvertSkill Many-To-One Skill.

Créer une entité Skill avec au moins un attribut name:

php bin/console generate:doctrine:entity

	*Donnez lui un nom
	*Choisissez le format par défault [annotation]
	*Nom du premier champs
	*Puis le type de champs
	*Puis la longueur du champs
	** Répétez l'opération autant de fois que vous avez de champs.
	** Puis une fois terminé faites "Entrée" et choisissez "yes" pour générer pour créer un repository vide.

Ensuite créer une entité de relation AdvertSkill sans utiliser le CMD en créant un fichier AdvertSkill.php

comme suit:

<?php
// src/FC/PlatformBundle/Entity/AdvertSkill.php

namespace FC\PlatformBundle\Entity;

use Doctrine\ORM\Mapping as ORM;

/**
 * @ORM\Entity(repositoryClass="FC\PlatformBundle\Entity\AdvertSkillRepository")
 */
class AdvertSkill
{
  /**
   * @ORM\Column(name="id", type="integer")
   * @ORM\Id
   * @ORM\GeneratedValue(strategy="AUTO")
   */
  private $id;

  /**
   * @ORM\Column(name="level", type="string", length=255)
   */
  private $level;

  /**
   * @ORM\ManyToOne(targetEntity="FC\PlatformBundle\Entity\Advert")
   * @ORM\JoinColumn(nullable=false)
   */
  private $advert;

  /**
   * @ORM\ManyToOne(targetEntity="FC\PlatformBundle\Entity\Skill")
   * @ORM\JoinColumn(nullable=false)
   */
  private $skill;
  
  // ... vous pouvez ajouter d'autres attributs bien sûr
}

Ensuite mettre à jour votre base de données:

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

## Créer un fixture pour l'entité skill ##

<?php
// src/FC/PlatformBundle/DataFixtures/ORM/LoadSkill.php

namespace FC\PlatformBundle\DataFixtures\ORM;

use Doctrine\Common\DataFixtures\FixtureInterface;
use Doctrine\Common\Persistence\ObjectManager;
use FC\PlatformBundle\Entity\Skill;

class LoadSkill implements FixtureInterface
{
  public function load(ObjectManager $manager)
  {
    // Liste des noms de compétences à ajouter
    $names = array('PHP', 'Symfony2', 'C++', 'Java', 'Photoshop', 'Blender', 'Bloc-note');

    foreach ($names as $name) {
      // On crée la compétence
      $skill = new Skill();
      $skill->setName($name);

      // On la persiste
      $manager->persist($skill);
    }

    // On déclenche l'enregistrement de toutes les catégories
    $manager->flush();
  }
}

Pour insérer ses données dans la base de données:

depuis le CMD:

php bin/console doctrine:fixtures:load

répondez 'y'

Et voilà les catégories sont créées !

	## Relation bidirectionnelles ##

Nous allons ici construire une relation bidirectionnelle de type Many-To-One.

Nous allons rajouter un attribut, et son annotation, à notre entité inverse "Advert"
afin de rendre possible l'accès.

/**
     * @ORM\OneToMany(targetEntity="FC\PlatformBundle\Entity\Application",mappedBy="advert")
     */
    private $applications; // Notez le " s ", une annonce est liée à plusieurs candidatures

Nous allons également adapter l'entité propriétaire "Application" pour indiquer que la relation est
de type bidirectionnelle.


/**
     * @ORM\ManyToOne(targetEntity="FC\PlatformBundle\Entity\Advert",inversedBy="applications")
     * @ORM\JoinColumn(nullable=false)
     */
    private $advert;

il faut générer les getter et les setter depuis le CMD:

php bin/console doctrine:generate:entities FCPlatformBundle:Advert

ensuite mettre à jour la base de données :

	php bin/console doctrine:schema:update --dump-sql (Créer la requête)

Puis:

	php bin/console doctrine:schema:update --force (Pour exécuter la requête)

Afin d'éviter d'avoir à être obligé de définir les deux entités simultanéments à chaque fois
on va le définir dans une des deux par exemple "Advert"

public function addApplication(Application $application)
{
  $this->applications[] = $application;

  // On lie l'annonce à la candidature
  $application->setAdvert($this);
    
  return $this;
}


                  ### LE REPOSITORY ###

Afin de récupérer les entités depuis un repository il existe deux méthodes:

## DQL Doctrine Query Language ##

ex: SELECT a FROM FCPlatformBundle:Advert a

## QueryBuilder ##

ex: $QueryBuilder->select('a')->from('FCPlatformBundle:Advert', 'a');



## Les méthodes de récupération de base ##

	# Les méthodes normales #

		1) find($id)
		
		ex: $repository = $this
					->getDoctrine()
					->getManager()
					->getRepository('FCPlatformBundle:Advert');
		    $advert = $repository->find(5); // $advert est une instance de 
		                                    // FCPlatformBundle:Advert correspondant à l'id 5.

		2) findAll()

		ex: $repository = $this
					->getDoctrine()
					->getManager()
					->getRepository('FCPlatformBundle:Advert');
		    $listAdverts = $repository->findAll();
		    foreach ($listAdverts as $advert) {
		     // $advert est une instance de Advert
			echo $advert->getContent();
		    }

		3) findBy()

		    // La syntaxe est la suivante
		    $repository->findBy(
			array $criteria,
			array $orderBy = null,
			$limit = null,
			$offset = null
		    );
		ex: $listAdverts = $repository->findBy(
			array('author' => 'Alexandre'), // Critere
			array('date' => 'desc'),        // Tri
			5,                              // Limite
  			0				// Offset
		    );

		4) findOneBy()

		ex: $advert = $repository->findOneBy(array('author' => 'Marine'));

	# Les méthodes magiques #

		1) findByX($valeur) // Le X peut être remplacé par une propriété de Advert renvoie une ou plusieurs lignes (affichage à l'aide d'un "for" sous twig)

		ex: $listAdverts = $repository->findByAuthor('Alexandre');

		2) findOneByX($valeur) // Le X peut être remplacé par une propriété de Advert renvoie une seule ligne (affichage sans "for" sous twig)

		ex: $advert = $repository->findByOneTitle('Recherche développeur.');




## Les méthodes de récupération personnelles ##	

	# Le QueryBuilder #

	Dans un premier nous allons créer notre propre méthode en rajoutant une function dans AdvertRepository.php qui est dans :

 	src/FC/PlatformBundle/Entity/AdvertRepository.php ou src/FC/PlatformBundle/Repository/AdvertRepository.php

						Détail de la function 

	public function myFindAll()
	{
		// Méthode 1 en passant par l'EntityManager
		$queryBuilder = $this->_em->createQueryBuilder()->select('a')->from($this->_entityName, 'a');
		// Dans un repository, $this->_entityName est le namespace de l'entité gérée
		// Ici, il vaut donc FC\PlatformBundle\Entity\Advert

		// Méthode 2 : en passant par le raccourci (je recommande)
		$queryBuilder = $this->createQueryBuilder('a');

		// On n'ajoute pas de critère ou tri particulier, la construction 
		// de notre requête est finie

		// On récupère la Query à partir du QueryBuilder
		$query = $queryBuilder->getQuery();

		// On récupère les résultats à partir de la Query
		$results = $query->getResult();

		// On retourne ces résultats
		return $results;
	}
	
	public function myFindOne($id) // Similaire au find($id)
	{
		$qb = $this->createQueryBuilder('a');

		$qb->where('a.id = :id')->setParameter('id', $id);

		return $qb->getQuery()->getResult();
	}

	public function findByAuthorAnDate($author, $datetime) // Deux paramètres author et datetime
	{
		$qb = $this->createQueryBuilder('a');

		$qb->where('a.author = :author')->setParameter('author', $author)
		   ->andWhere('a.date = :datetime')->setParameter('datetime', $datetime)
		   ->orderBy('a.date', 'DESC');

		return $qb->getQuery()->getResult();
	}

	public function myFindOne($id) // Similaire au find($id)
	{
		$qb = $this->createQueryBuilder('a');

		$qb->where('a.id = :id')->setParameter('id', $id);

		return $qb->getQuery()->getResult();
	}

	public function findByAuthorAnDate($author, $year) // Deux paramètres author et year
	{
		$year = $year."-00-00 00:00:00"; // On formate une datetime par défaut à partir de l'année choisie
		$qb = $this->createQueryBuilder('a');

		$qb->where('a.author = :author')->setParameter('author', $author)
		   ->andWhere('a.date > :year')->setParameter('year', $year)
		   ->orderBy('a.date', 'DESC');

		return $qb->getQuery()->getResult();
	}

	Pour cette fonction on oublie pas d'intégrer le "use" : use Doctrine\ORM\QueryBuilder;

	public function whereCurrentYear(QueryBuilder $qb)
	{
		$qb
			->andWhere('a.date BETWEEN :start AND :end')
			->setParameter('start', new \Datetime(date('Y').'-01-01')) // Date entre le 1er janvier de cette année
			->setParameter('end', new \Datetime(date('Y').'-12-31')); // Et le 31 décembre cette année
	}

	public function  myFind()
	{
		$qb = $this->createQueryBuilder('a');

		// On peut ajouter ce qu'on veut avant
		$qb
			->where('a.author = :author')
			->setParameter('author', 'Boris');

		// On applique notre condition sur le QueryBuilder
		$this->whereCurrentYear($qb);

		// On peut ajouter ce qu'on veut après
		$qb->orderBy('a.date', 'DESC');

		return $qb->getQuery()->getResult();
	}

	# Liste non exhaustives des méthodes de Query #

	getQuery() : Exécute la requête.

	getResult() : Retourne la requête exécutée.
 
		ex: $listAdverts = $qb->getQuery()->getResult();

	    	    foreach ($listAdverts as $advert) {
  	    	    	// $advert est une instance d'Advert dans notre exemple
  	    	    	$advert->getContent();
	    	    }

	getArrayResult()

		ex: $listAdverts = $qb->getQuery()->getArrayResult();

		    foreach ($listAdverts as $advert) {
  			// $advert est un tableau
  			// Faire $advert->getContent() est impossible. Vous devez faire :
  			$advert['content'];
		    }
	
	getScalarResult()

		ex: $values = $qb->getQuery()->getScalarResult();

		    foreach ($values as $value) {
  			// $value est la valeur de ce qui a été sélectionné : un nombre, un texte, etc.
  			$value;

  			// Faire $value->getAttribute() ou $value['attribute'] est impossible
		    }


	getOneOrNullResult()

		ex: $advert = $qb->getQuery()->getOneOrNullResult();

			// $advert est une instance d'Advert dans notre exemple
			// Ou null si la requête ne contient pas de résultat

			// Et une exception a été déclenchée si plus d'un résultat

	getSingleResult()

		ex: $advert = $qb->getQuery()->getSingleResult();

			// $advert est une instance d'Advert dans notre exemple

			// Une exception a été déclenchée si plus d'un résultat
			// Une exception a été déclenchée si pas de résultat

	getSingleScalarResult()

		ex: $value = $qb->getQuery()->getSingleScalarResult();

			// $value est directement la valeur du COUNT dans la requête exemple

			// Une exception a été déclenchée si plus d'un résultat
			// Une exception a été déclenchée si pas de résultat

	execute() // Principalement des requêtes qui ne retournent pas de résultat (des UPDATE, INSERT INTO, etc....)

		ex: 	// Exécute un UPDATE par exemple :
		    $qb->getQuery()->execute();	


	Cependant toutes les autres méthodes que nous venons de voir ne sont en fait que des raccourcis vers cette méthode execute(),
	en changeant juste le mode d'hydratation des résultats(objet, tableau, etc...).

	ex: // Voici deux méthodes strictement équivalentes :
	    $results = $query->getArrayResult();
	    // Et :
	    $results = $query->execute(array(), Query::HYDRATE_ARRAY);

	    // Le premier argument de execute() est un tableau de paramètres
	    // Vous pouvez aussi passer par la méthode setParameter(), au choix

	    // Le deuxième argument de execute() est la dite méthode d'hydratation



	# Le Doctrine Query Language DQL #

	Pour créer une requête en utilisant de DQL, il faut utiliser la méthode createQuery() de l'EntityManager:

	ex:

	// Depuis un repository
	public function myFindAllDQL()
	{
  		$query = $this->_em->createQuery('SELECT a FROM OCPlatformBundle:Advert a');
  		$results = $query->getResult();

  		return $results;
	}
	
	

## Utiliser les jointures dans nos requêtes ##	

	# Avec le QueryBuilder #

	// Depuis le repository d'Advert
	public function getAdvertWithApplications()
	{
		$qb = $this->createQueryBuilder('a')
				   ->leftJoin('a.applications', 'app')
				   ->addSelect('app');

		return $qb
				  ->getQuery()
				  ->getResult();
				  
	}
## Les événements doctrine ##

		# Liste des évènements de cycle de vie #

*Évènement 	*Description

PrePersist	L'évènement PrePersist se produit juste avant que l'EntityManager ne persiste effectivement l'entité. Concrètement, cela exécute le callback juste avant un $em->persist($entity). Il ne concerne que les entités nouvellement créées. Du coup, il y a deux conséquences : d'une part, les modifications que vous apportez à l'entité seront persistées en base de données, puisqu'elles sont effectives avant que l'EntityManager n'enregistre l'entité en base. D'autre part, vous n'avez pas accès à l'id de l'entité si celui-ci est autogénéré, car justement l'entité n'est pas encore enregistrée en base de données, et donc l'id pas encore généré.
PostPersist	L'évènement postPersist se produit juste après que l'EntityManager ait effectivement persisté l'entité. Attention, cela n'exécute pas le callback juste après le $em->persist($entity), mais juste après le $em->flush(). À l'inverse du prePersist, les modifications que vous apportez à l'entité ne seront pas persistées en base (mais seront tout de même appliquées à l'entité, attention) ; mais vous avez par contre accès à l'id qui a été généré lors du flush().
PreUpdate	L'évènement preUpdate se produit juste avant que l'EntityManager ne modifie une entité. Par modifiée, j'entends que l'entité existait déjà, que vous y avez apporté des modifications, puis un $em->flush(). Le callback sera exécuté juste avant le flush(). Attention, il faut que vous ayez modifié au moins un attribut pour que l'EntityManager génère une requête et donc déclenche cet évènement.
		Vous avez accès à l'id autogénéré (car l'entité existe déjà), et vos modifications seront persistées en base de données.
PostUpdate	L'évènement postUpdate se produit juste après que l'EntityManager a effectivement modifié une entité. Vous avez accès à l'id et vos modifications ne sont pas persistées en base de données.
PreRemove	L'évènement PreRemove se produit juste avant que l'EntityManager ne supprime une entité, c'est-à-dire juste avant un $em->flush() qui précède un $em->remove($entite). Attention, soyez prudents dans cet évènement, si vous souhaitez supprimer des fichiers liés à l'entité par exemple, car à ce moment l'entité n'est pas encore effectivement supprimée, et la suppression peut être annulée en cas d'erreur dans une des opérations à effectuer dans le flush().
PostRemove	L'évènement PostRemove se produit juste après que l'EntityManager a effectivement supprimé une entité. Si vous n'avez plus accès à son id, c'est ici que vous pouvez effectuer une suppression de fichier associé par exemple.
PostLoad	L'évènement PostLoad se produit juste après que l'EntityManager a chargé une entité (ou après un $em->refresh()). Utile pour appliquer une action lors du chargement d'une entité.

(Attention, ces évènements se produisent lorsque vous créez et modifiez vos entités en manipulant les objets. Ils ne sont pas déclenchés lorsque vous effectuez des requêtes DQL ou avec le QueryBuilder. Car ces requêtes peuvent toucher un grand nombre d'entités et il serait dangereux pour Doctrine de déclencher les évènements correspondants un à un).


	# Définir un callback de cycle de vie

	ex:
 
	- Dans l'entité Advert nous allons ajouter un champs représentant la date de la dernière édition de l'annonce.

	
	/**
 	  * @ORM\Column(name="updated_at", type="datetime", nullable=true)
 	  */
	  private $updatedAt;


	N'oubliez pas de mettre à jour la base de données:
	

			php bin/console doctrine:schema:update --dump-sql (Créer la requête)

		Puis:

			php bin/console doctrine:schema:update --force (Pour exécuter la requête)

	  - Définir ensuite l'entité comme contenant des callbacks

	
		<?php
		// src/OC/PlatformBundle/Entity/Advert.php

		namespace OC\PlatformBundle\Entity;

		/**
 		 * @ORM\Entity(repositoryClass="OC\PlatformBundle\Entity\AdvertRepository")
 		* @ORM\HasLifecycleCallbacks()
 	 	*/
		class Advert
		{
  			// …

  	  		public function updateDate()
  	  		{
    				$this->setUpdatedAt(new \Datetime());
  	 		}
		}

	  - Maintenant il faut dire à Doctrine d'exécuter cette méthode


		 	